### 第十五关挑战：海量场景问题该如何解决

* 原题目：给定一个输入文件，包含40亿个非负整数，请设计一个算法，产生一个不存在该文件中的整数，假设你有1GB的内存来完成这项任务。
* 现在请你思考：让你将这40亿中不存在的整数，全部找出来，该如何做？

## 解题过程

看到`40亿`数据就知道是`海量数据类型`题目，考虑使用`位存储`、`分块处理`、`堆`等方式。
* __明确限制条件__：1GB内存
* __明确大致做法__：遍历数据，统计并存储每个数是否存在的情况，最后遍历输出不存在的值。
* __考虑使用位存储__：对于每个整数，只有存在和不存在两个状态，正好可以使用二进制位的值1、0来表示。所以每个整数的状态存储仅需占用1个位，1个字节可以存储8个整数的状态。
    * 计算位图存储40亿数据状态 需要多少内存：
        ```txt
        4000000000/8/1024/1024/1024 = 0.47G ≈ 0.5G //这里只需要0.5G 此时还满足题意
        ```
* __考虑极端情况__：40亿数据都是重复的，此时不存在的整数有40亿-1个，则返回的数据列表占用内存为：
    ```txt
    (4000000000-1)*4/1024/1024/1024 ≈ 15G  //此时已经超过题目限制了，需要考虑分块处理
    ```
* __考虑根据内存限制，需要分成多少块更合适__
    - 计算 1G内存 能存储多少个int数据
        ```txt
        1*1024*1024*1024/4 = 268435456(个)
        4000000000/268435456 ≈ 15(块)
        ```
    - 所以 __40亿__ 数据，至少需要分割成 __15块__。
    - 而一般情况下，我们推荐分割为 __2的整数倍__，所以这里分割成 __16块__ 更合适，每块处理 __268435456个__ 数据。
    - 确保相同数据进入同一块中：分块（这里使用取余的方式）来保证相同数据进入同一块中。
* __然后依次对每块数据，使用位存储状态，找出当前块中不存在的整数__
* __最后汇总所有块的不存在的整数，返回即可__

### 代码实现
```go
func FindNoExistNumsBy1G(arr []int) (res []int) {
	N := 16 //分成16块
	for i := 0; i < N; i++ {
		res = append(res, FindNoExistNumsByPiece(arr, i)...)
	}
	return
}

// 单独统计每块中不存在的整数
func FindNoExistNumsByPiece(arr []int, targetIndex int) (res []int) {
	N := 268435456                //分成16块，每块处理的平均数
	bitmap := make([]int, N/32+1) //最多占用8MB

	// 统计当前块中数据的存在情况
	for _, num := range arr {
		if num%N == targetIndex {
			index := num / 32
			offset := num % 32
			mark := 1 << offset
			bitmap[index] |= mark
		}
	}
	// 找出不存在的数据
	for index, val := range bitmap {
		for i := 0; i < 32; i++ {
			mark := 1 << i
			if val&mark == 0 {
				// 计算不存在的整数值并添加到结果中
				num := i + index*32 + targetIndex*N
				res = append(res, num)
			}
		}
	}
	return
}
```


